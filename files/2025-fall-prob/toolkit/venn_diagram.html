<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>事件运算互动演示器 | Venn Diagram Explorer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;900&family=Noto+Sans+SC:wght@400;500;700&display.swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', 'Noto Sans SC', sans-serif;
        }
        .op-button.active {
            background-color: #3b82f6; /* blue-500 */
            color: white;
            font-weight: bold;
        }
        .demorgan1.active {
            background-color: #14b8a6; /* teal-500 */
            color: white;
            font-weight: bold;
        }
        .demorgan2.active {
            background-color: #6366f1; /* indigo-500 */
            color: white;
            font-weight: bold;
        }
        .canvas-container {
            width: 100%;
            height: 100%;
            min-height: 400px;
        }
    </style>
</head>
<body class="bg-slate-100 text-slate-800 flex flex-col min-h-screen">

    <div class="container mx-auto p-4 md:p-8 flex-grow">
        
        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-slate-900">事件运算互动演示器</h1>
            <p class="text-slate-600 mt-2">通过可交互的韦恩图理解事件的关系</p>
        </header>

        <main class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            
            <div class="lg:col-span-2 bg-white rounded-2xl shadow-lg p-4 flex flex-col items-center justify-center relative canvas-container">
                <canvas id="vennCanvas" class="rounded-lg"></canvas>
                <div id="formulaDisplay" class="absolute bottom-4 left-4 bg-black bg-opacity-50 text-white p-2 rounded-lg text-xl font-mono">
                    请选择一个运算
                </div>
            </div>

            <div class="bg-white rounded-2xl shadow-lg p-6">
                <h2 class="text-2xl font-bold mb-4 border-b pb-2">选择运算</h2>
                <p class="text-sm text-slate-600 mb-4">点击下面的按钮来高亮显示对应的区域。你可以拖动A和B两个事件圆圈。</p>
                
                <div class="space-y-4">
                    <!-- Basic Operations -->
                    <div>
                        <h3 class="font-semibold mb-2 text-slate-700">基本运算</h3>
                        <div class="grid grid-cols-2 gap-2">
                            <button onclick="setOperation(this, 'A_union_B')" class="op-button bg-slate-200 hover:bg-blue-500 hover:text-white text-slate-800 font-semibold py-2 px-4 rounded-lg transition-colors">A ∪ B (并)</button>
                            <button onclick="setOperation(this, 'A_intersect_B')" class="op-button bg-slate-200 hover:bg-blue-500 hover:text-white text-slate-800 font-semibold py-2 px-4 rounded-lg transition-colors">A ∩ B (交)</button>
                            <button onclick="setOperation(this, 'A_minus_B')" class="op-button bg-slate-200 hover:bg-blue-500 hover:text-white text-slate-800 font-semibold py-2 px-4 rounded-lg transition-colors">A - B (差)</button>
                            <button onclick="setOperation(this, 'B_minus_A')" class="op-button bg-slate-200 hover:bg-blue-500 hover:text-white text-slate-800 font-semibold py-2 px-4 rounded-lg transition-colors">B - A (差)</button>
                            <button onclick="setOperation(this, 'not_A')" class="op-button bg-slate-200 hover:bg-blue-500 hover:text-white text-slate-800 font-semibold py-2 px-4 rounded-lg transition-colors">Ā (A的补)</button>
                            <button onclick="setOperation(this, 'not_B')" class="op-button bg-slate-200 hover:bg-blue-500 hover:text-white text-slate-800 font-semibold py-2 px-4 rounded-lg transition-colors">B̄ (B的补)</button>
                        </div>
                    </div>

                    <!-- De Morgan's Law 1 -->
                    <div>
                        <h3 class="font-semibold mb-2 text-slate-700">德摩根定律 (1)</h3>
                        <div class="grid grid-cols-2 gap-2">
                            <button onclick="setOperation(this, 'not_A_union_B')" class="op-button demorgan1 bg-teal-100 hover:bg-teal-500 hover:text-white text-teal-800 font-semibold py-2 px-4 rounded-lg transition-colors">¬(A ∪ B)</button>
                            <button onclick="setOperation(this, 'not_A_intersect_not_B')" class="op-button demorgan1 bg-teal-100 hover:bg-teal-500 hover:text-white text-teal-800 font-semibold py-2 px-4 rounded-lg transition-colors">¬A ∩ ¬B</button>
                        </div>
                    </div>

                    <!-- De Morgan's Law 2 -->
                    <div>
                        <h3 class="font-semibold mb-2 text-slate-700">德摩根定律 (2)</h3>
                        <div class="grid grid-cols-2 gap-2">
                            <button onclick="setOperation(this, 'not_A_intersect_B')" class="op-button demorgan2 bg-indigo-100 hover:bg-indigo-500 hover:text-white text-indigo-800 font-semibold py-2 px-4 rounded-lg transition-colors">¬(A ∩ B)</button>
                            <button onclick="setOperation(this, 'not_A_union_not_B')" class="op-button demorgan2 bg-indigo-100 hover:bg-indigo-500 hover:text-white text-indigo-800 font-semibold py-2 px-4 rounded-lg transition-colors">¬A ∪ ¬B</button>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        const canvas = document.getElementById('vennCanvas');
        const ctx = canvas.getContext('2d');
        const formulaDisplay = document.getElementById('formulaDisplay');

        let currentOperation = null;
        
        function createPattern(color, angle) {
            const pCanvas = document.createElement('canvas');
            const pCtx = pCanvas.getContext('2d');
            pCanvas.width = 10;
            pCanvas.height = 10;
            pCtx.strokeStyle = color;
            pCtx.lineWidth = 2;
            pCtx.beginPath();
            if (angle === 'left') { pCtx.moveTo(0, 10); pCtx.lineTo(10, 0); } 
            else { pCtx.moveTo(0, 0); pCtx.lineTo(10, 10); }
            pCtx.stroke();
            return ctx.createPattern(pCanvas, 'repeat');
        }

        const highlightPatternSingle = createPattern('rgba(59, 130, 246, 0.8)', 'right');
        const highlightPatternA = createPattern('rgba(59, 130, 246, 0.7)', 'right');
        const highlightPatternB = createPattern('rgba(22, 163, 74, 0.7)', 'left');

        const circles = [
            { id: 'A', x: 0, y: 0, radius: 0, color: 'rgba(239, 68, 68, 0.35)', isDragging: false },
            { id: 'B', x: 0, y: 0, radius: 0, color: 'rgba(34, 197, 94, 0.35)', isDragging: false }
        ];

        function resizeCanvas() {
            const container = canvas.parentElement;
            const dpr = window.devicePixelRatio || 1;
            const rect = container.getBoundingClientRect();
            
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            canvas.style.width = `${rect.width}px`;
            canvas.style.height = `${rect.height}px`;
            
            ctx.scale(dpr, dpr);

            circles[0].x = rect.width * 0.35;
            circles[0].y = rect.height * 0.5;
            circles[0].radius = Math.min(rect.width, rect.height) * 0.25;
            
            circles[1].x = rect.width * 0.65;
            circles[1].y = rect.height * 0.5;
            circles[1].radius = Math.min(rect.width, rect.height) * 0.25;

            draw();
        }

        function draw() {
            const w = canvas.clientWidth;
            const h = canvas.clientHeight;
            ctx.clearRect(0, 0, w, h);
            ctx.fillStyle = '#f8fafc';
            ctx.fillRect(0, 0, w, h);

            circles.forEach(circle => {
                ctx.beginPath();
                ctx.arc(circle.x, circle.y, circle.radius, 0, 2 * Math.PI);
                ctx.fillStyle = circle.color;
                ctx.fill();
            });

            if (currentOperation) {
                applyOperation(currentOperation);
            }
            
            ctx.strokeStyle = '#94a3b8';
            ctx.lineWidth = 4;
            ctx.strokeRect(0, 0, w, h);
            ctx.font = '24px Inter';
            ctx.fillStyle = '#64748b';
            ctx.fillText('Ω', 20, 30);
            
            circles.forEach(circle => {
                ctx.beginPath();
                ctx.arc(circle.x, circle.y, circle.radius, 0, 2 * Math.PI);
                ctx.strokeStyle = '#334155';
                ctx.lineWidth = 3;
                ctx.stroke();
                ctx.fillStyle = '#1e293b';
                ctx.font = 'bold 32px Inter';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(circle.id, circle.x, circle.y);
            });
        }

        function applyOperation(op) {
            const w = canvas.clientWidth;
            const h = canvas.clientHeight;
            const [A, B] = circles;

            ctx.save();
            
            switch (op) {
                // --- Basic Operations ---
                case 'A_union_B':
                    ctx.fillStyle = highlightPatternSingle;
                    ctx.beginPath();
                    ctx.arc(A.x, A.y, A.radius, 0, 2 * Math.PI);
                    ctx.arc(B.x, B.y, B.radius, 0, 2 * Math.PI);
                    ctx.fill();
                    break;
                case 'A_intersect_B':
                    ctx.fillStyle = highlightPatternSingle;
                    ctx.beginPath();
                    ctx.arc(A.x, A.y, A.radius, 0, 2 * Math.PI);
                    ctx.clip();
                    ctx.beginPath();
                    ctx.arc(B.x, B.y, B.radius, 0, 2 * Math.PI);
                    ctx.fill();
                    break;
                case 'A_minus_B':
                    ctx.fillStyle = highlightPatternSingle;
                    ctx.beginPath();
                    ctx.arc(A.x, A.y, A.radius, 0, 2 * Math.PI);
                    ctx.clip();
                    ctx.beginPath();
                    ctx.rect(0, 0, w, h);
                    ctx.arc(B.x, B.y, B.radius, 0, 2 * Math.PI, true);
                    ctx.fill();
                    break;
                case 'B_minus_A':
                    ctx.fillStyle = highlightPatternSingle;
                    ctx.beginPath();
                    ctx.arc(B.x, B.y, B.radius, 0, 2 * Math.PI);
                    ctx.clip();
                    ctx.beginPath();
                    ctx.rect(0, 0, w, h);
                    ctx.arc(A.x, A.y, A.radius, 0, 2 * Math.PI, true);
                    ctx.fill();
                    break;
                case 'not_A':
                    ctx.fillStyle = highlightPatternA;
                    ctx.beginPath();
                    ctx.rect(0, 0, w, h);
                    ctx.arc(A.x, A.y, A.radius, 0, 2 * Math.PI, true);
                    ctx.fill();
                    break;
                case 'not_B':
                    ctx.fillStyle = highlightPatternB;
                    ctx.beginPath();
                    ctx.rect(0, 0, w, h);
                    ctx.arc(B.x, B.y, B.radius, 0, 2 * Math.PI, true);
                    ctx.fill();
                    break;
                
                // --- De Morgan's Law 1 ---
                case 'not_A_union_B': // ¬(A ∪ B) - Result view
                    ctx.fillStyle = highlightPatternSingle;
                    ctx.beginPath();
                    ctx.rect(0, 0, w, h);
                    ctx.arc(A.x, A.y, A.radius, 0, 2 * Math.PI, true);
                    ctx.clip();

                    ctx.beginPath();
                    ctx.rect(0, 0, w, h);
                    ctx.arc(B.x, B.y, B.radius, 0, 2 * Math.PI, true);
                    ctx.fill();
                    break;
                case 'not_A_intersect_not_B': // ¬A ∩ ¬B - Component view
                    ctx.fillStyle = highlightPatternA;
                    ctx.beginPath();
                    ctx.rect(0, 0, w, h);
                    ctx.arc(A.x, A.y, A.radius, 0, 2 * Math.PI, true);
                    ctx.fill();
                    
                    ctx.fillStyle = highlightPatternB;
                    ctx.beginPath();
                    ctx.rect(0, 0, w, h);
                    ctx.arc(B.x, B.y, B.radius, 0, 2 * Math.PI, true);
                    ctx.fill();
                    break;

                // --- De Morgan's Law 2 ---
                case 'not_A_intersect_B': // ¬(A ∩ B) - Result view
                    ctx.fillStyle = highlightPatternSingle;
                    ctx.beginPath();
                    ctx.rect(0, 0, w, h);
                    ctx.arc(A.x, A.y, A.radius, 0, 2 * Math.PI, true);
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.rect(0, 0, w, h);
                    ctx.arc(B.x, B.y, B.radius, 0, 2 * Math.PI, true);
                    ctx.fill();
                    break;

                case 'not_A_union_not_B': // ¬A ∪ ¬B - Component view
                    ctx.fillStyle = highlightPatternA;
                    ctx.beginPath();
                    ctx.rect(0, 0, w, h);
                    ctx.arc(A.x, A.y, A.radius, 0, 2 * Math.PI, true);
                    ctx.fill();
                    
                    ctx.fillStyle = highlightPatternB;
                    ctx.beginPath();
                    ctx.rect(0, 0, w, h);
                    ctx.arc(B.x, B.y, B.radius, 0, 2 * Math.PI, true);
                    ctx.fill();
                    break;
            }
            ctx.restore();
        }

        function setOperation(button, op) {
            document.querySelectorAll('.op-button').forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');
            
            currentOperation = op;
            const formulas = {
                'A_union_B': 'A ∪ B', 'A_intersect_B': 'A ∩ B', 'A_minus_B': 'A - B',
                'B_minus_A': 'B - A', 'not_A': 'Ā', 'not_B': 'B̄',
                'not_A_union_B': '¬(A ∪ B)', 'not_A_intersect_not_B': '¬A ∩ ¬B',
                'not_A_intersect_B': '¬(A ∩ B)', 'not_A_union_not_B': '¬A ∪ ¬B'
            };
            formulaDisplay.textContent = formulas[op] || '请选择一个运算';
            draw();
        }

        let activeCircle = null;
        let offsetX, offsetY;

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            for (let i = circles.length - 1; i >= 0; i--) {
                const circle = circles[i];
                const dx = mouseX - circle.x;
                const dy = mouseY - circle.y;
                if (dx * dx + dy * dy < circle.radius * circle.radius) {
                    activeCircle = circle;
                    offsetX = dx;
                    offsetY = dy;
                    canvas.style.cursor = 'grabbing';
                    return;
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!activeCircle) return;
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            activeCircle.x = mouseX - offsetX;
            activeCircle.y = mouseY - offsetY;
            draw();
        });

        canvas.addEventListener('mouseup', () => {
            activeCircle = null;
            canvas.style.cursor = 'grab';
        });

        canvas.addEventListener('mouseleave', () => {
            activeCircle = null;
            canvas.style.cursor = 'default';
        });
        
        canvas.addEventListener('mouseenter', () => {
            canvas.style.cursor = 'grab';
        });

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

    </script>
</body>
</html>
